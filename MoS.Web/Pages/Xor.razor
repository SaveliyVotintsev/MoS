@page "/xor-shift"

<MudContainer>
    <MudStack Spacing="6">
        <MudText Typo="Typo.h5">Симметричное шифрование</MudText>

        <MudStack Spacing="3">
            <MudTabs MinimumTabWidth="20px" @bind-ActivePanelIndex="ActiveTabIndex">
                <MudTabPanel Text="Символ">
                    <MudTextField @bind-Value="InputSymbol" Label="Введите символ" MaxLength="1" />
                </MudTabPanel>
                <MudTabPanel Text="ALT-код">
                    <MudNumericField @bind-Value="InputAltCode" Label="Введите ALT-код" />
                </MudTabPanel>
                <MudTabPanel Text="Слово">
                    <MudTextField @bind-Value="InputWord" Label="Введите слово" />
                </MudTabPanel>
            </MudTabs>
            <MudNumericField @bind-Value="NumberOfRounds" Label="Количество раундов" Min="1" />
            <MudTextField @bind-Value="KeyShifts" Label="Смещения ключа (через пробел)" />
            <MudText Typo="Typo.body2" Color="Color.Info">
                Введите положительные значения для сдвига вправо и отрицательные для сдвига влево.
            </MudText>
            <MudSwitch Color="Color.Success" UncheckedColor="Color.Error" @bind-Value="IsEncryptMode" Label="@(IsEncryptMode ? "Шифрование" : "Дешифрование")" />
            <MudButton OnClick="Process" Variant="Variant.Filled" Color="Color.Primary">Выполнить</MudButton>
        </MudStack>

        <MudTable Items="Table" Breakpoint="Breakpoint.None">
            <HeaderContent>
                <MudTh>Символ</MudTh>
                <MudTh>ALT-код</MudTh>
                <MudTh>Исходный код (2СС)</MudTh>
                <MudTh>Результат (2СС)</MudTh>
                <MudTh>ALT-код</MudTh>
                <MudTh>Символ</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>@context.Symbol</MudTd>
                <MudTd>@context.Code</MudTd>
                <MudTd>@context.BinCode</MudTd>
                <MudTd>@context.S</MudTd>
                <MudTd>@context.FinalResult</MudTd>
                <MudTd>@(context.FinalChar?.ToString() ?? "-")</MudTd>
            </RowTemplate>
        </MudTable>

        <MudTabs MinimumTabWidth="20px" @bind-ActivePanelIndex="ResultTabIndex">
            @foreach (KeyValuePair<string, string> result in Results)
            {
                <MudTabPanel Text="@result.Key">
                    <MudText Typo="Typo.body1">Результат:</MudText>
                    @foreach (string line in result.Value.Split("\n"))
                    {
                        <MudText Typo="Typo.body2">@line</MudText>
                    }
                </MudTabPanel>
            }
        </MudTabs>
    </MudStack>
</MudContainer>

@code {
    private Dictionary<string, string> Results { get; } = new();
    public string InputSymbol { get; set; } = string.Empty;
    public string InputAltCode { get; set; } = string.Empty;
    public string InputWord { get; set; } = string.Empty;
    public int ActiveTabIndex { get; set; } = 2;
    public int ResultTabIndex { get; set; }
    public int NumberOfRounds { get; set; } = 2;
    public string KeyShifts { get; set; } = "1 1";
    public bool IsEncryptMode { get; set; }

    [Inject]
    private HttpClient Client { get; set; }

    private readonly Dictionary<int, char> altCodes = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadAltCodesAsync();
    }

    private async Task LoadAltCodesAsync()
    {
        string fileContent = await Client.GetStringAsync("data/alt-codes.txt");
        string[] lines = fileContent.Split(Environment.NewLine, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);

        foreach (string line in lines)
        {
            string[] parts = line.Split(' ');

            if (parts.Length == 2 && int.TryParse(parts[0], out int code))
            {
                altCodes[code] = parts[1][0];
            }
        }
    }

    private string Shift(string a, int n)
    {
        n = n % a.Length;

        if (n < 0)
        {
            n = a.Length + n;
        }

        return a[^n..] + a[..^n];
    }

    private string XorStrings(string a, string b)
    {
        return string.Concat(a.Zip(b, (x, y) => (int.Parse(x.ToString()) ^ int.Parse(y.ToString())).ToString()));
    }

    private void Process()
    {
        try
        {
            Results.Clear();
            Table.Clear();

            if (ActiveTabIndex == 0)
            {
                if (InputSymbol.Length != 1)
                {
                    Results["Ошибка"] = "Ошибка: Введите только один символ.\n";
                    return;
                }

                ProcessSingleSymbol(altCodes.First(x => x.Value == InputSymbol[0]).Key, InputSymbol);
            }
            else if (ActiveTabIndex == 1)
            {
                if (!int.TryParse(InputAltCode, out int code) || !altCodes.ContainsKey(code))
                {
                    Results["Ошибка"] = "Ошибка: Введите правильный ALT-код.\n";
                    return;
                }

                ProcessSingleSymbol(code, altCodes[code].ToString());
            }
            else if (ActiveTabIndex == 2)
            {
                if (string.IsNullOrWhiteSpace(InputWord))
                {
                    Results["Ошибка"] = "Ошибка: Введите слово.\n";
                    return;
                }

                foreach (char c in InputWord)
                {
                    ProcessSingleSymbol(altCodes.FirstOrDefault(x => x.Value == c).Key, c.ToString());
                }
            }
        }
        catch (Exception)
        {
            Results["Ошибка"] = "Ошибка: Введите правильный ALT-код.\n";
        }
    }

    private void ProcessSingleSymbol(int code, string symbol)
    {
        string result = string.Empty;
        result += $"Символ: {symbol}\n";
        result += $"Его ALT-код: {code}\n";

        result += $"Изначальный код, k = {code}\n";
        string binCode = Convert.ToString(code, 2).PadLeft(8, '0');
        result += "Код в 2СС: " + binCode + "\n";

        string leftHalf = binCode.Substring(0, 4);
        string rightHalf = binCode.Substring(4);

        List<int> keyShifts = KeyShifts.Split(' ').Select(int.Parse).ToList();

        if (!IsEncryptMode)
        {
            keyShifts.Reverse();
        }

        result += "------------\n";

        for (int i = 0; i < NumberOfRounds; i++)
        {
            int k = keyShifts[i % keyShifts.Count];
            result += $"Раунд {i + 1}, k = {k}\n";
            result += $"Левая часть = {leftHalf}\n";
            result += $"Правая часть = {rightHalf}\n";

            string shiftedLeftHalf = Shift(leftHalf, k);
            result += $"Сдвигаем левую часть на k = {k} ..\n";
            result += $"Результат сдвига = {shiftedLeftHalf}\n";

            result += "Выполняем XOR с правой частью..\n";
            rightHalf = XorStrings(shiftedLeftHalf, rightHalf);
            result += $"Результат XOR = {rightHalf}\n";

            if (i != NumberOfRounds - 1)
            {
                (leftHalf, rightHalf) = (rightHalf, leftHalf);
            }

            result += "Результат раунда: " + leftHalf + rightHalf + "\n";
            result += "------------\n";
        }

        string finalBinaryResult = leftHalf + rightHalf;
        result += "Результат финального раунда: " + finalBinaryResult + "\n";

        int finalResult = Convert.ToInt32(finalBinaryResult, 2);
        char finalChar = altCodes[finalResult];

        result += $"Новый код символа: {finalResult} (ALT-код: {finalResult}, Символ: {finalChar})\n";
        Table.Add(new Calc(symbol, code, binCode, To2(finalResult), finalResult, finalChar));
        Results[symbol] = result;
    }

    private readonly List<Calc> Table = new();

    private record Calc(string Symbol, int Code, string BinCode, string S, int FinalResult, char? FinalChar);

    public static string To2(int x)
    {
        return Convert.ToString(x, 2).PadLeft(4, '0');
    }

}
